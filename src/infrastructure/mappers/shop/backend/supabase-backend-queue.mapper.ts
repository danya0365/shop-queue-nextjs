import {
  QueueEntity,
  QueuePriority,
  QueueServiceEntity,
  QueueStatsEntity,
  QueueStatus,
} from "@/src/domain/entities/shop/backend/backend-queue.entity";
import { PaymentEntity, PaymentMethod, PaymentStatus } from "@/src/domain/entities/shop/backend/backend-payment.entity";
import { PaginationMeta } from "@/src/domain/interfaces/pagination-types";
import { PaymentSchema } from "@/src/infrastructure/schemas/shop/backend/payment.schema";
import {
  QueueSchema,
  QueueServiceSchema,
  QueueStatsSchema,
} from "@/src/infrastructure/schemas/shop/backend/queue.schema";

/**
 * Mapper class for converting between queue database schema and domain entities
 * Following Clean Architecture principles for separation of concerns
 */
export class SupabaseShopBackendQueueMapper {
  /**
   * Map database schema to domain entity
   * @param schema Queue database schema
   * @param services Queue services
   * @returns Queue domain entity
   */
  public static toDomain(
    schema: QueueSchema & { payments?: PaymentSchema[] }
  ): QueueEntity {
    return {
      id: schema.id,
      customerId: schema.customer_id,
      customerName: schema.customer_name || "",
      customerPhone: schema.customer_phone || "",
      shopId: schema.shop_id,
      shopName: schema.shop_name || "",
      queueServices:
        schema.queue_services?.map((queue_service) =>
          this.serviceToDomain(queue_service)
        ) || [],
      payments: schema.payments?.map((payment) => this.paymentToEntity(payment)) || [],
      queueNumber: schema.queue_number,
      status: schema.status as QueueStatus,
      priority: schema.priority as QueuePriority,
      estimatedWaitTime: schema.estimated_duration,
      actualWaitTime: schema.actual_wait_time,
      notes: schema.note || undefined,
      createdAt: schema.created_at,
      updatedAt: schema.updated_at,
      calledAt: schema.served_at || undefined,
      completedAt: schema.completed_at || undefined,
    };
  }

  /**
   * Map payment schema to domain entity
   * @param schema Payment database schema
   * @returns Payment domain entity
   */
  public static paymentToEntity(schema: PaymentSchema): PaymentEntity {
    return {
      id: schema.id,
      queueId: schema.queue_id,
      queueNumber: schema.queue_number,
      customerName: schema.customer_name,
      totalAmount: schema.total_amount,
      paidAmount: schema.paid_amount,
      paymentMethod: schema.payment_method as PaymentMethod | null,
      paymentStatus: schema.payment_status as PaymentStatus,
      paymentDate: schema.payment_date,
      processedByEmployeeId: schema.processed_by_employee_id,
      processedByEmployeeName: schema.processed_by_employee_name,
      shopId: schema.shop_id,
      shopName: schema.shop_name,
      createdAt: schema.created_at,
      updatedAt: schema.updated_at,
    };
  }

  /**
   * Map queue service schema to domain entity
   * @param schema Queue service schema
   * @returns Queue service domain entity
   */
  public static serviceToDomain(
    schema: QueueServiceSchema
  ): QueueServiceEntity {
    return {
      serviceId: schema.service_id,
      serviceName: schema.services?.name || "",
      quantity: schema.quantity,
      price: schema.price,
      total: schema.quantity * schema.price,
    };
  }

  /**
   * Map domain entity to database schema
   * @param entity Queue domain entity
   * @returns Queue database schema
   */
  public static toSchema(entity: QueueEntity): QueueSchema {
    return {
      id: entity.id,
      customer_id: entity.customerId,
      customer_name: entity.customerName,
      customer_phone: entity.customerPhone,
      shop_id: entity.shopId,
      shop_name: entity.shopName,
      queue_number: entity.queueNumber.toString(),
      status: entity.status,
      priority: entity.priority,
      estimated_duration: entity.estimatedWaitTime,
      estimated_call_time: null, // This would be calculated on the server
      served_by_employee_id: null, // This would be set when a queue is served
      note: entity.notes || null,
      feedback: null, // This would be set when feedback is provided
      rating: null, // This would be set when rating is provided
      created_at: entity.createdAt,
      updated_at: entity.updatedAt,
      served_at: entity.calledAt || null,
      completed_at: entity.completedAt || null,
      actual_wait_time: entity.actualWaitTime,
    };
  }

  /**
   * Map queue service domain entity to database schema
   * @param entity Queue service domain entity
   * @param queueId Queue ID
   * @returns Queue service database schema
   */
  public static serviceToSchema(
    entity: QueueServiceEntity,
    queueId: string
  ): QueueServiceSchema {
    return {
      id: "", // This would be generated by the database
      queue_id: queueId,
      service_id: entity.serviceId,
      quantity: entity.quantity,
      price: entity.price,
    };
  }

  /**
   * Map queue stats schema to domain entity
   * @param schema Queue stats database schema
   * @returns Queue stats domain entity
   */
  public static statsToEntity(schema: QueueStatsSchema): QueueStatsEntity {
    return {
      // Today's statistics
      totalQueueToday: schema.total_queue_today,
      waitingQueueToday: schema.waiting_queue_today,
      confirmedQueueToday: schema.confirmed_queue_today,
      servingQueueToday: schema.serving_queue_today,
      inProgressQueueToday: schema.in_progress_queue_today,
      totalCompletedToday: schema.total_completed_today,
      totalCancelledToday: schema.total_cancelled_today,

      // All-time statistics
      allQueueTotal: schema.all_queue_total,
      allWaitingQueue: schema.all_waiting_queue,
      allConfirmedQueue: schema.all_confirmed_queue,
      allServingQueue: schema.all_serving_queue,
      allInProgressQueue: schema.all_in_progress_queue,
      allCompletedTotal: schema.all_completed_total,
      allCancelledTotal: schema.all_cancelled_total,

      // Performance metrics
      avgWaitTimeMinutes: schema.avg_wait_time_minutes,

      // Shop-specific data (optional)
      shopId: schema.shop_id,
    };
  }

  /**
   * Create pagination metadata from database results
   * @param page Current page number
   * @param limit Items per page
   * @param totalItems Total number of items
   * @returns Pagination metadata
   */
  public static createPaginationMeta(
    page: number,
    limit: number,
    totalItems: number
  ): PaginationMeta {
    const totalPages = Math.ceil(totalItems / limit);

    return {
      currentPage: page,
      totalPages,
      totalItems,
      itemsPerPage: limit,
      hasNextPage: page < totalPages,
      hasPrevPage: page > 1,
    };
  }
}
