import type { ServiceEntity, ServiceStatsEntity } from '@/src/domain/entities/backend/ServiceEntity';
import { DatabaseDataSource } from '@/src/domain/interfaces/datasources/database-datasource';
import { Logger } from '@/src/domain/interfaces/logger';
import type { BackendServiceRepository } from '@/src/domain/repositories/backend/BackendServiceRepository';
import { SupabaseBackendServiceMapper } from '@/src/infrastructure/mappers/backend/SupabaseBackendServiceMapper';
import { ServiceSchema } from '@/src/infrastructure/schemas/backend/service-schema';

export class SupabaseBackendServiceRepository implements BackendServiceRepository {
  constructor(private readonly dataSource: DatabaseDataSource, private readonly logger: Logger) { }

  async getServicesWithStats(
    page: number,
    limit: number,
    filters?: {
      searchQuery?: string;
      categoryFilter?: string;
      availabilityFilter?: string;
      shopId?: string;
    }
  ): Promise<{
    services: ServiceEntity[];
    stats: ServiceStatsEntity;
    totalCount: number;
    currentPage: number;
    totalPages: number;
  }> {
    try {
      const offset = (page - 1) * limit;

      // Build query with filters
      let query = this.dataSource.getClient()
        .from('services')
        .select('*', { count: 'exact' });

      // Apply filters
      if (filters?.searchQuery) {
        query = query.or(`name.ilike.%${filters.searchQuery}%,description.ilike.%${filters.searchQuery}%`);
      }

      if (filters?.categoryFilter) {
        query = query.eq('category', filters.categoryFilter);
      }

      if (filters?.availabilityFilter) {
        const isAvailable = filters.availabilityFilter === 'available';
        query = query.eq('is_available', isAvailable);
      }

      if (filters?.shopId) {
        query = query.eq('shop_id', filters.shopId);
      }

      // Execute query with pagination
      const { data: servicesData, error: servicesError, count } = await query
        .range(offset, offset + limit - 1)
        .order('created_at', { ascending: false });

      if (servicesError) {
        throw new Error(`Failed to fetch services: ${servicesError.message}`);
      }

      // Get stats
      const stats = await this.getServiceStats(filters?.shopId);

      // Validate and map services
      const validatedServices = servicesData?.map((service: any) => {
        const validatedService = ServiceSchema.parse(service);
        return SupabaseBackendServiceMapper.toDomain(validatedService);
      }) || [];

      const totalCount = count || 0;
      const totalPages = Math.ceil(totalCount / limit);

      return {
        services: validatedServices,
        stats,
        totalCount,
        currentPage: page,
        totalPages,
      };
    } catch (error) {
      throw new Error(`Failed to get services with stats: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async getServiceById(id: string): Promise<ServiceEntity | null> {
    try {
      const { data, error } = await this.dataSource.getClient()
        .from('services')
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null; // Not found
        }
        throw new Error(`Failed to fetch service: ${error.message}`);
      }

      const validatedService = ServiceSchema.parse(data);
      return SupabaseBackendServiceMapper.toDomain(validatedService);
    } catch (error) {
      throw new Error(`Failed to get service by ID: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async createService(service: Omit<ServiceEntity, 'id' | 'createdAt' | 'updatedAt'>): Promise<ServiceEntity> {
    try {
      const serviceData = SupabaseBackendServiceMapper.toDatabase({
        ...service,
        id: '', // Will be generated by database
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });

      const { data, error } = await this.dataSource.getClient()
        .from('services')
        .insert(serviceData)
        .select()
        .single();

      if (error) {
        throw new Error(`Failed to create service: ${error.message}`);
      }

      const validatedService = ServiceSchema.parse(data);
      return SupabaseBackendServiceMapper.toDomain(validatedService);
    } catch (error) {
      throw new Error(`Failed to create service: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async updateService(id: string, updates: Partial<ServiceEntity>): Promise<ServiceEntity> {
    try {
      const updateData = SupabaseBackendServiceMapper.toDatabase({
        ...updates,
        id,
        updatedAt: new Date().toISOString(),
      } as ServiceEntity);

      const { data, error } = await this.dataSource.getClient()
        .from('services')
        .update(updateData)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        throw new Error(`Failed to update service: ${error.message}`);
      }

      const validatedService = ServiceSchema.parse(data);
      return SupabaseBackendServiceMapper.toDomain(validatedService);
    } catch (error) {
      throw new Error(`Failed to update service: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async deleteService(id: string): Promise<boolean> {
    try {
      const { error } = await this.dataSource.getClient()
        .from('services')
        .delete()
        .eq('id', id);

      if (error) {
        throw new Error(`Failed to delete service: ${error.message}`);
      }

      return true;
    } catch (error) {
      throw new Error(`Failed to delete service: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async toggleAvailability(id: string, isAvailable: boolean): Promise<boolean> {
    try {
      const { error } = await this.dataSource.getClient()
        .from('services')
        .update({
          is_available: isAvailable,
          updated_at: new Date().toISOString()
        })
        .eq('id', id);

      if (error) {
        throw new Error(`Failed to toggle service availability: ${error.message}`);
      }

      return true;
    } catch (error) {
      throw new Error(`Failed to toggle service availability: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async updatePopularityRank(id: string, rank: number): Promise<boolean> {
    try {
      const { error } = await this.dataSource.getClient()
        .from('services')
        .update({
          popularity_rank: rank,
          updated_at: new Date().toISOString()
        })
        .eq('id', id);

      if (error) {
        throw new Error(`Failed to update popularity rank: ${error.message}`);
      }

      return true;
    } catch (error) {
      throw new Error(`Failed to update popularity rank: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private async getServiceStats(shopId?: string): Promise<ServiceStatsEntity> {
    try {
      // Get basic service counts
      let countQuery = this.dataSource.getClient()
        .from('services')
        .select('*', { count: 'exact', head: true });

      if (shopId) {
        countQuery = countQuery.eq('shop_id', shopId);
      }

      const { count: totalServices } = await countQuery;

      // Get available services count
      let availableQuery = this.dataSource.getClient()
        .from('services')
        .select('*', { count: 'exact', head: true })
        .eq('is_available', true);

      if (shopId) {
        availableQuery = availableQuery.eq('shop_id', shopId);
      }

      const { count: availableServices } = await availableQuery;

      // Get services data for calculations
      let servicesQuery = this.dataSource.getClient()
        .from('services')
        .select('price, category');

      if (shopId) {
        servicesQuery = servicesQuery.eq('shop_id', shopId);
      }

      const { data: servicesData } = await servicesQuery;

      // Calculate stats
      const prices = servicesData?.map((s: any) => s.price) || [];
      const averagePrice = prices.length > 0 ? prices.reduce((a: number, b: number) => a + b, 0) / prices.length : 0;

      // Group by category
      const servicesByCategory: { [key: string]: number } = {};
      servicesData?.forEach((service: any) => {
        const category = service.category || 'ไม่มีหมวดหมู่';
        servicesByCategory[category] = (servicesByCategory[category] || 0) + 1;
      });

      // Mock popular services (in real implementation, this would come from queue_services joins)
      const popularServices = [
        { id: '1', name: 'บริการยอดนิยม 1', bookingCount: 50 },
        { id: '2', name: 'บริการยอดนิยม 2', bookingCount: 35 },
        { id: '3', name: 'บริการยอดนิยม 3', bookingCount: 28 },
      ];

      return {
        totalServices: totalServices || 0,
        availableServices: availableServices || 0,
        unavailableServices: (totalServices || 0) - (availableServices || 0),
        averagePrice,
        totalRevenue: 0, // Would need to calculate from payments
        servicesByCategory,
        popularServices,
      };
    } catch (error) {
      throw new Error(`Failed to get service stats: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}
